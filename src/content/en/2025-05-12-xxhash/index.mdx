---
title: 'xxHash: the fastest hashing algorithm in the .NET ecosystem'
description: 'How to use xxHash in C# for fast, stable hash computation without allocations'
pubDate: 'May 12 2025'
tags: ['C#', 'Performance', 'Algorithms']
lang: 'en'
---

import { Image } from 'astro:assets'
import benchmark from './benchmark.png'

Recently at work, I needed to compute a stable hash for some objects. My first thought was to use one of the standard cryptographic algorithms — SHA1, SHA256, SHA512, or MD5. But they all have two major drawbacks:

1. The hashes are large — from 160 to 512 bits.
2. They return a byte array, which leads to unnecessary memory allocations.

That made me look for alternatives. I quickly found the [xxHash repository](https://github.com/Cyan4973/xxHash) and its [C# implementation](https://learn.microsoft.com/en-us/dotnet/api/system.io.hashing.xxhash3). What sets xxHash apart is its high performance and the ability to get a hash as an integer value.

It's important to note that xxHash is **not** a cryptographic algorithm. It's designed for other tasks like fast hashing, data comparison, and generating cache keys or database indexes.

## xxHash in .NET

To use xxHash in your .NET app, you just need to install the [System.IO.Hashing](https://www.nuget.org/packages/System.IO.Hashing) package. It includes four implementations of the xxHash algorithm:

| Algorithm | Hash size |
| :-------- | :-------- |
| XxHash32  | 32 bits   |
| XxHash64  | 64 bits   |
| XxHash3   | 64 bits   |
| XxHash128 | 128 bits  |

## Performance

I [benchmarked](https://github.com/alexeyfv/DotNetBenchmarks/tree/main/Hashing) these algorithms against each other, and also compared them to SHA1, SHA2, SHA3, and MD5. The results are as follows:

<Image
  src={benchmark}
  alt="Comparison of xxHash speed with other hash algorithms"
/>
<strong style="text-align: center;">
  Benchmark results: xxHash outperforms SHA and MD5 by a large margin
</strong>

As expected, xxHash proved to be significantly faster than the alternatives.

## Example usage

xxHash is particularly convenient because of the following features:

– **The `Append` method** — allows you to add data incrementally without intermediate allocations.  
– **Integer-based output** — depending on the algorithm, you can get the hash as `uint`, `ulong`, or `UInt128` instead of a byte array.  
– **Support for `Span<T>`** — lets you use stack memory and avoid heap allocations.

Here’s an example of how to compute a stable hash with xxHash:

```csharp
public class SomeObject
{
    [ThreadStatic]
    private static readonly XxHash3 hasher;

    static SomeObject() => hasher = new();

    public required int IntValue { get; init; }
    public required string StringValue { get; init; }
    public required DateTimeOffset DateTimeValue { get; init; }

    public ulong GetStableHashCode()
    {
        hasher.Reset();

        var idBytes = MemoryMarshal.Cast<int, byte>([IntValue]);
        hasher.Append(idBytes);

        var bytesCount = Encoding.UTF8.GetByteCount(StringValue);
        Span<byte> stringBytes = stackalloc byte[bytesCount];
        Encoding.UTF8.GetBytes(StringValue, stringBytes);
        hasher.Append(stringBytes);

        var unixTime = DateTimeValue.ToUnixTimeMilliseconds();
        var dateBytes = MemoryMarshal.Cast<long, byte>([unixTime]);
        hasher.Append(dateBytes);

        return hasher.GetCurrentHashAsUInt64();
    }
}
```

## Conclusion

Using xxHash for stable hash computation gives you several key benefits:

- High performance — one of the fastest hashing algorithms available.
- Zero allocations — with `Span` and `Append`, you can compute hashes using only the stack and CPU registers.
- Compact representation — store the hash as `uint` or `ulong` (just 4 or 8 bytes). These values are easy to index in a database and simplify SQL query structure. Instead of a complex `WHERE col1 = ... AND col2 = ...`, you can just query `WHERE Hash = ...`. This becomes especially useful when working with tables containing hundreds of millions of rows.
